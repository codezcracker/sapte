"use strict";
/**
 * Functions for rendering components using Preact "X" (v10 and later) and
 * converting the result to a React Standard Tree (RST) format defined by
 * Enzyme.
 *
 * Preact 10+ stores details of the rendered elements on internal fields of
 * the VNodes. A reference to the vnode is stored in the root DOM element.
 * The rendered result is converted to RST by traversing these vnode references.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNode = exports.rstNodeFromElement = void 0;
var preact_1 = require("preact");
var array_prototype_flatmap_1 = __importDefault(require("array.prototype.flatmap"));
var compat_1 = require("./compat");
var preact10_internals_1 = require("./preact10-internals");
var shallow_render_utils_1 = require("./shallow-render-utils");
function stripSpecialProps(props) {
    var children = props.children, key = props.key, ref = props.ref, otherProps = __rest(props, ["children", "key", "ref"]);
    return otherProps;
}
function convertDOMProps(props) {
    var srcProps = stripSpecialProps(props);
    var converted = {};
    Object.keys(srcProps).forEach(function (srcProp) {
        var destProp = srcProp === 'class' ? 'className' : srcProp;
        converted[destProp] = props[srcProp];
    });
    return converted;
}
/**
 * Convert the rendered output of a vnode to RST nodes.
 */
function rstNodesFromChildren(nodes) {
    if (!nodes) {
        return [];
    }
    return array_prototype_flatmap_1.default(nodes, function (node) {
        if (node === null) {
            // The array of rendered children may have `null` entries as a result of
            // eg. conditionally rendered children where the condition was false.
            //
            // These are omitted from the rendered tree that Enzyme works with.
            return [];
        }
        var rst = rstNodeFromVNode(node);
        return Array.isArray(rst) ? rst : [rst];
    });
}
function rstNodeFromVNode(node) {
    if (node == null) {
        return null;
    }
    // Preact 10 represents text nodes as VNodes with `node.type == null` and
    // `node.props` equal to the string content.
    if (typeof node.props === 'string' || typeof node.props === 'number') {
        return String(node.props);
    }
    if (node.type === preact_1.Fragment) {
        return rstNodesFromChildren(preact10_internals_1.getChildren(node));
    }
    var component = preact10_internals_1.getComponent(node);
    if (component) {
        return rstNodeFromComponent(node, component);
    }
    if (!preact10_internals_1.getDOMNode(node)) {
        throw new Error("Expected VDOM node to be a DOM node but got " + node.type);
    }
    return {
        nodeType: 'host',
        type: node.type,
        props: convertDOMProps(node.props),
        key: node.key || null,
        ref: node.ref || null,
        instance: preact10_internals_1.getDOMNode(node),
        rendered: rstNodesFromChildren(preact10_internals_1.getChildren(node)),
    };
}
function nodeTypeFromType(type) {
    if (typeof type === 'string') {
        return 'host';
    }
    else if (type.prototype && typeof type.prototype.render === 'function') {
        return 'class';
    }
    else if (typeof type === 'function') {
        return 'function';
    }
    else {
        throw new Error("Unknown node type: " + type);
    }
}
/**
 * Convert a JSX element tree returned by Preact's `h` function into an RST
 * node.
 */
function rstNodeFromElement(node) {
    if (node == null || typeof node === 'string') {
        return node;
    }
    var children = compat_1.childElements(node).map(rstNodeFromElement);
    var nodeType = nodeTypeFromType(node.type);
    var props = {};
    if (typeof node.props === 'object' && node.props) {
        props =
            nodeType === 'host'
                ? convertDOMProps(node.props)
                : stripSpecialProps(node.props);
    }
    var ref = node.ref || null;
    return {
        nodeType: nodeType,
        type: node.type,
        props: props,
        key: node.key || null,
        ref: ref,
        instance: null,
        rendered: children,
    };
}
exports.rstNodeFromElement = rstNodeFromElement;
/**
 * Return a React Standard Tree (RST) node from a Preact `Component` instance.
 */
function rstNodeFromComponent(vnode, component) {
    var nodeType = nodeTypeFromType(component.constructor);
    var rendered = rstNodesFromChildren(preact10_internals_1.getLastRenderOutput(component));
    // If this was a shallow-rendered component, set the RST node's type to the
    // real component function/class.
    var shallowRenderedType = shallow_render_utils_1.getRealType(component);
    var type = shallowRenderedType
        ? shallowRenderedType
        : component.constructor;
    return {
        nodeType: nodeType,
        type: type,
        props: __assign({ children: [] }, component.props),
        key: vnode.key || null,
        ref: vnode.ref || null,
        instance: component,
        rendered: rendered,
    };
}
/**
 * Convert the Preact components rendered into `container` into an RST node.
 */
function getNode(container) {
    var rendered = preact10_internals_1.getLastVNodeRenderedIntoContainer(container);
    var rstNode = rstNodeFromVNode(rendered);
    // There is currently a requirement that the root element produces a single
    // RST node. Fragments do not appear in the RST tree, so it is fine if the
    // root node is a fragment, provided that it renders only a single child. In
    // fact Preact itself wraps the root element in a single-child fragment.
    if (Array.isArray(rstNode)) {
        if (rstNode.length === 1) {
            return rstNode[0];
        }
        else {
            throw new Error('Root element must not be a fragment with multiple children');
        }
    }
    else {
        return rstNode;
    }
}
exports.getNode = getNode;
